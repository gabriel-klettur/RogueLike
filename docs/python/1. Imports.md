## 1. Cómo funciona el sistema de imports

1. **Búsqueda de módulos**

   * Python mantiene una lista `sys.path` (directorio actual, variables de entorno, rutas de instalación).
   * Al hacer `import paquete.modulo`, recorre `sys.path` buscando un directorio `paquete` con un `__init__.py`, o un archivo `paquete.py`.
   * Por defecto, el directorio desde el que lanzas el intérprete (o el `PYTHONPATH`) va primero en `sys.path`.

2. **Cache y .pyc**

   * Cuando importas, el bytecode compilado (`.pyc`) se guarda en `__pycache__/`.
   * Si el `.py` no ha cambiado, Python cargará el `.pyc` para acelerar arranques posteriores.

---

## 2. Módulos, paquetes y namespace packages

* **Módulo**: un archivo `.py`.
* **Paquete**: un directorio con un `__init__.py`.
* **Namespace package** (PEP 420): un paquete **sin** `__init__.py` que puede distribuirse en múltiples carpetas. Útil para plugins o distribuciones fragmentadas.

---

## 3. Absolute vs. Relative Imports

### Imports absolutos (recomendados)

```python
from roguelike_engine.camera.camera import Camera
```

* Claros y robustos: siempre sabes de dónde viene cada cosa.
* Funcionan igual en desarrollo y en instalación con `pip install -e .`.

### Imports relativos (solo dentro de un mismo paquete)

```python
# En src/roguelike_engine/camera/utils.py
from ..config    import ASSETS_DIR
from .loader     import load_image
```

* Úsalos **solo** para importar módulos vecinos.
* Evita más de dos niveles (`from ...subpkg.mod import X`), suele volverse confuso.

---

## 4. El archivo `__init__.py`

* **Inicializa el paquete**: puedes ejecutar código de setup o exponer API pública.
* Para controlar lo que `from paquete import *` importa, define `__all__`:

  ```python
  # __init__.py
  __all__ = ["camera", "input", "utils"]
  ```
* Mantén `__init__.py` ligero: evita lógica de alto coste o efectos secundarios al importarlo.

---

## 5. Control de exportaciones con `__all__`

Dentro de un módulo:

```python
__all__ = ["Camera", "apply_zoom"]

class Camera: ...
def apply_zoom(...): ...
def _internal_helper(...): ...
```

* `from modulo import *` sólo traerá lo listado en `__all__`.
* Las funciones o clases cuyo nombre empiece por `_` se consideran privadas.

---

## 6. Organización de tu proyecto (“src layout”)

```
RogueLike/
├── pyproject.toml  ← metadata del paquete
├── setup.cfg       ← configuración de instalación
├── src/
│   ├── roguelike_engine/
│   └── roguelike_game/
└── launcher.py     ← sólo un “wrapper” o usa entry-point
```

* **Ventaja**: separa código de proyecto de otros archivos.
* Instálalo con:

  ```bash
  pip install -e .
  ```
* Así, tus imports absolutos siempre funcionarán sin hacks de `sys.path`.

---

## 7. Buenas prácticas de estilo (PEP 8)

1. **Orden de imports** (usa [isort](https://github.com/PyCQA/isort)):

   1. Imports de librería estándar.
   2. Imports de terceros.
   3. Imports de tu propio paquete.
2. **Una línea en blanco** entre cada grupo.
3. Evita `from paquete import *` en producción: ensucia el namespace y dificulta mantenimiento.

---

## 8. Evitar imports circulares

* Un import circular ocurre cuando A importa B y B importa A.
* **Soluciones**:

  * Mover la importación dentro de la función o método que lo usa (importación tardía).
  * Extraer la parte común a un tercer módulo sin dependencias.
  * Replantear tu diseño (SEP de responsabilidades).

**Ejemplo de import tardío**:

```python
# en module_a.py
def func_a():
    from module_b import func_b
    func_b()
```

---

## 9. Imports dinámicos y `importlib`

* Para cargar módulos por nombre en tiempo de ejecución:

  ```python
  import importlib
  mod = importlib.import_module("roguelike_engine.utils.loader")
  ```
* Útil para plugins, cargar configuraciones o recursos de forma genérica.

---

## 10. Recursos y assets en tiempo de ejecución

* Para datos no-Python (imágenes, JSON), evita mezclar con código:

  ```python
  from importlib import resources

  with resources.path("roguelike_engine.assets.tiles", "floor.png") as img_path:
      img = pygame.image.load(img_path)
  ```
* Esto funciona incluso si empaquetas tu juego en un zip o wheel.

---

## 11. Optimización de imports

* **Lazy imports**: retrasa módulos pesados hasta que realmente los necesites.
* **Evita** poner mucho código en imports de nivel superior (`__init__.py`); esto ralentiza el arranque.

---

## 12. Tipado estático y stubs

* Para mejorar la autocompletación y el chequeo estático:

  * Añade **type hints** en tus funciones y clases.
  * Usa archivos `.pyi` (stubs) si necesitas exponer solo interfaz.
  * Integra **mypy** en tu CI para validar firmas de importados.

---

## 13. Resumen de “maestro de imports”

1. **Prefiere imports absolutos** y un layout basado en `src/`.
2. **Usa `__init__.py` y `__all__`** para exponer tu API con claridad.
3. Sigue **PEP 8/isort** para el orden y formato de tus imports.
4. **Evita circulares** con importaciones perezosas o refactorizaciones.
5. Gestiona **assets** con `importlib.resources`.
6. Incorpora **lazy imports** y `importlib` para flexibilidad en tiempo de ejecución.
7. Añade **tipado estático** para robustez y mantenibilidad.

Con estos principios llevarás tus importaciones al nivel profesional: código limpio, arranques rápidos, y proyectos fácilmente empaquetables y testeables. ¡A practicar!
