## Documentación: Implementación de Modo Multijugador Online

### 1. Flujo de Menú

**Menú Principal (ESC)**

* Cambiar personaje
* Modo multijugador → abre submenú MP
* Salir

**Submenú "Modo multijugador"**

1. **Conectarse por IP**

   * El usuario introduce únicamente la IP pública del host.
   * Se usa un puerto por defecto (`8765`).
2. **Hostear partida**

   * El juego arranca un servidor embebido en el puerto por defecto (`8765`).
   * Se detecta y muestra automáticamente la IP pública del host.
   * No se pide más configuración al usuario.
3. **Conectarse al servidor principal**

   * Conexión al `WEBSOCKET_URL` configurado en `config.py`.
4. **Volver**

   * Regresa al menú principal sin cambios.

---

### 2. Puertos y Configuración de Red

* **Puerto por defecto:** 8765 (configurable en `config.py`).
* **IP pública:** obtenida automáticamente con un servicio HTTP (p.ej. `https://api.ipify.org`).
* **No requiere abrir puertos manualmente** si se implementa:

  * **UPnP/NAT-PMP**: mapeo automático de puertos en routers compatibles.
  * **Hole-punching (STUN/TURN)**: técnica de WebRTC para atravesar NAT.

---

### 3. Estrategias de NAT Traversal

1. **UPnP / NAT-PMP**

   * Pros: fácil, transparente si el router lo soporta.
   * Contras: no todos los routers lo tienen activo.
   * Ejemplo de uso en Python con `miniupnpc`:

     ```python
     import miniupnpc
     upnp = miniupnpc.UPnP()
     upnp.discoverdelay = 200
     upnp.discover()
     upnp.selectigd()
     external_ip = upnp.externalipaddress()
     upnp.addportmapping(8765, 'UDP', upnp.lanaddr, 8765, 'MiRoguelikeHost', '')
     ```

2. **Hole-Punching (STUN/TURN)**

   * STUN: descubre la IP/puerto públicos.
   * TURN: relé cuando el comportamiento directo falla.
   * Se puede usar `aiortc` (WebRTC) en Python para integrar ambas.

3. **Solución Steamworks**

   * Steam Networking SDK maneja NAT traversal + relé.
   * Requiere publicar en Steam.

4. **Servicios de terceros**

   * Photon, Mirror Relay, Nakama, etc.
   * Ofrecen NAT traversal y servidores relé.

---

### 4. Componentes a Desarrollar

* **UI**: nuevo submenú en `Menu` con navegación de flechas y Enter.
* **Cliente**: parametrizar `WebSocketClient` para conectar a IP/puerto personalizados.
* **Host local**: integrar UPnP o WebRTC en el cliente para abrir puertos automáticamente y exponer IP.
* **Servidor principal**: mantener fuera del cliente; el cliente se conecta con la opción 3.

---

### 5. Estructura de Carpetas Propuesta

```text
RogueLike/
├── src/
│   ├── roguelike_engine/
│   │   ├── networking/                    ← Lógica genérica de cliente/servidor y NAT-traversal
│   │   │   ├── __init__.py
│   │   │   ├── client.py                  ← Cliente TCP/WebSocket parametrizable
│   │   │   ├── server.py                  ← Servidor embebido (host local)
│   │   │   ├── upnp.py                    ← Helpers UPnP / NAT-PMP
│   │   │   └── stun_turn.py               ← Helpers STUN/TURN (WebRTC / aiortc)
│   │   └── ...
│   ├── roguelike_game/
│   │   ├── network/                       ← Código específico del juego para modo online
│   │   │   ├── __init__.py
│   │   │   ├── manager.py                 ← GameNetworkManager: orquesta host/cliente
│   │   │   ├── ui_client_connection.py    ← Diálogos de “Conectarse por IP” y “Conectar al servidor principal”
│   │   │   ├── ui_host_lobby.py           ← Pantalla de “Hostear partida” (muestra IP pública y estado)
│   │   │   └── config.py                  ← Valores por defecto (puerto, URLs)
│   │   ├── ui/
│   │   │   └── menus/
│   │   │       └── multiplayer_menu.py    ← Nuevo sub-menú “Modo multijugador”
│   │   └── main.py                        ← Aquí llamas a GameNetworkManager desde el menú
│   └── ...
├── launcher.py
└── requirements.txt
```

**Descripción:**

* **roguelike\_engine/networking**: encapsula la lógica de bajo nivel para cliente, servidor y NAT traversal.
* **roguelike\_game/network**: coordina esa lógica genérica con la experiencia concreta del juego.
* **roguelike\_game/ui/menus**: contiene el menú y diálogos necesarios para la interacción del jugador.

---

### 6. Siguientes Pasos Propuestos

1. Diseñar la UI del submenú y pantallas de entrada/espera.
2. Implementar la obtención automática de IP pública.
3. Probar UPnP con `miniupnpc` y gestionar fallback a TURN si falla.
4. Integrar la lógica de arranque de servidor embebido en el cliente.
5. Test de conectividad end-to-end entre dos clientes.

---

